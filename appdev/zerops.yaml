# Two setups cover the full development lifecycle:
# 'prod' compiles an optimized release binary and deploys only the artifact.
# 'dev' deploys the full source tree so a developer can SSH in and run
# 'cargo run' without needing a local Rust toolchain.
zerops:
  - setup: prod
    build:
      # rust@stable gives the full Rust toolchain (rustc + cargo) in the build container.
      # The build container is temporary — it compiles the binary and is deleted afterward;
      # only the compiled artifact is kept and deployed to runtime containers.
      base: rust@stable

      envVariables:
        # Redirect Cargo's home directory into the project dir (.cargo/) so that
        # both cache: and deployFiles: can reference it — ~/.cargo is outside
        # /build/source and inaccessible to both by default.
        CARGO_HOME: .cargo

      buildCommands:
        # --release enables optimizations (inlining, dead-code elimination, LTO).
        # --locked enforces Cargo.lock reproducibility — fails if lock file is out of sync,
        # which is correct for production: deterministic builds, no surprise dependency upgrades.
        - cargo build --release --locked

      # Deploy only the compiled binary — runtime containers don't need source code,
      # the Cargo registry, or the toolchain. Minimal artifact = smaller deploy, faster startup.
      deployFiles:
        - ./target/release/rust-hello-world

      # Cache the Cargo registry and compiled intermediates between builds.
      # First build: Cargo downloads and compiles all crates from scratch (~minutes).
      # Subsequent builds: registry restored from cache, only changed code recompiles (~seconds).
      cache:
        - .cargo
        - target

    # readinessCheck runs during each deployment BEFORE the project balancer routes
    # traffic to the new container. Zerops waits for HTTP 200 on this endpoint —
    # guaranteeing the app is up and the database connection is live before serving users.
    deploy:
      readinessCheck:
        httpGet:
          port: 8080
          path: /

    run:
      # ubuntu@22.04 provides the glibc runtime that dynamically-linked Rust binaries require.
      # The binary compiled with rust@stable links against glibc by default.
      base: ubuntu@22.04

      ports:
        - port: 8080
          httpSupport: true

      # Rust has no garbage collector, so memory usage is predictable and low.
      # Reserve ~30% of minRam as free headroom for async runtime overhead
      # and traffic spikes — sufficient without OOM risk.
      verticalAutoscaling:
        minRam: 0.125
        minFreeRamGB: 0.05

      envVariables:
        # Zerops injects service credentials using the pattern {hostname}_{key}.
        # Since the database service is named 'db', the available variables are
        # db_hostname, db_port, db_user, db_password, and db_dbName.
        DB_HOST: ${db_hostname}
        DB_PORT: ${db_port}
        DB_USER: ${db_user}
        DB_PASS: ${db_password}
        DB_NAME: db

      # Path matches deployFiles exactly — binary deployed at ./target/release/rust-hello-world
      # lands at /var/www/target/release/rust-hello-world in the runtime container.
      start: ./target/release/rust-hello-world

  - setup: dev
    build:
      base: rust@stable

      envVariables:
        # Same CARGO_HOME redirect as prod — keeps registry in project dir for caching.
        CARGO_HOME: .cargo

      buildCommands:
        # Pre-fetch all crate dependencies without compiling.
        # The developer will run 'cargo run' themselves after SSHing in.
        # Skipping cargo build is intentional — the developer will edit code immediately,
        # making any pre-compiled output stale. Fetching only saves the download step.
        - cargo fetch

      # Deploy the full source tree including .cargo/ (the fetched registry).
      # The developer runs 'cargo run' in the runtime container — cargo finds the
      # registry in /var/www/.cargo (set via CARGO_HOME below) and compiles locally.
      deployFiles:
        - ./

      cache:
        - .cargo  # Subsequent dev pushes skip crate downloads
        - target  # Cached compiled output speeds up cargo run after first build

    run:
      base: rust@stable

      ports:
        - port: 8080
          httpSupport: true

      envVariables:
        DB_HOST: ${db_hostname}
        DB_PORT: ${db_port}
        DB_USER: ${db_user}
        DB_PASS: ${db_password}
        DB_NAME: db
        # Tell cargo in the runtime container where the deployed registry lives.
        # Without this, cargo looks in ~/.cargo/ and re-downloads everything on first run.
        CARGO_HOME: /var/www/.cargo

      # Dev is developer-driven: Zerops prepares the workspace and stays idle.
      # SSH in and run: cargo run
      # The Cargo registry is already at /var/www/.cargo — no internet required.
      start: zsc noop --silent
